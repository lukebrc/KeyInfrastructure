<database_planning_summary>
## Project Overview
The KeyInfrastructure project requires a PostgreSQL database to manage certificates and keys for a network of devices. The system supports user registration, certificate generation/renewal, and administrative management with requirements for 100 users, 10 certificates per user, and 10 concurrent users.

## Core Database Architecture Decisions

### User Management & Authentication
- **Roles**: ENUM type with values 'ADMIN' and 'USER' for role-based access control
- **Password Security**: HMAC-SHA256 hashing implemented in Rust backend, no algorithm metadata storage required
- **Session Management**: Stateless JWT tokens, no session storage in database
- **User Data**: Username, hashed password, role, creation date, last login date

### Certificate & Key Management
- **Table Structure**: Separate tables for certificates, private_keys, and revoked_certificates
- **Serial Numbers**: Cryptographically secure random values generated in Rust, validated for uniqueness in database
- **Certificate Storage**: Binary format (BYTEA) for certificates and encrypted private keys
- **DN Fields**: Single TEXT column storing DN as string (e.g., "C=PL,CN=username,O=Organization")
- **Renewal Tracking**: Single 'renewed' counter field, renewal date, and admin/reason tracking
- **Versioning**: Current version only, no historical certificate data retention

### Security Implementation
- **Encryption**: AES-256 for private key backup with separate salt column (BYTEA)
- **PIN Management**: PIN not stored in database, used only for PKCS#12 file encryption
- **Row Level Security**: Users see only their certificates, admins see all certificates
- **Access Control**: Certificates visible to users after admin creation and assignment

### Performance & Scalability
- **Table Partitioning**: Monthly partitions by expiration_date with 2-year cleanup
- **Indexing Strategy**: 
  - Primary indexes on user_id, certificate_serial_number, expiration_date
  - Composite indexes on (user_id, status) and (expiration_date, status)
  - Partial indexes for active certificates only
- **Query Optimization**: PostgreSQL functions for expiring certificates (7-day window)
- **Connection Pooling**: 5-20 connections with 30-second timeout

### CRL (Certificate Revocation List) Management
- **Revocation Storage**: Separate revoked_certificates table with serial numbers and revocation dates
- **CRL Generation**: Latest CRL stored in database, generated by Rust backend
- **Revocation Tracking**: Serial number, revocation date, and reason code storage

### Data Types & Constraints
- **Primary Keys**: UUID for global uniqueness across all tables
- **Timestamps**: TIMESTAMPTZ for proper timezone handling
- **Constraints**: UNIQUE on certificate serial numbers, username uniqueness, PIN length validation (8+ characters)
- **Foreign Keys**: Proper CASCADE rules for data integrity

### Operational Requirements
- **Backup Strategy**: Regular backups for encrypted private keys and CA data
- **Monitoring**: Certificate expiration alerts and database performance monitoring
- **Migration**: Automated partition creation and cleanup procedures
- **Development**: Comprehensive seed data and test database setup

## Technical Implementation Details
- **Database**: PostgreSQL with pgcrypto extension
- **Backend Integration**: Rust with actix-web and sqlx for database operations
- **Storage Format**: Binary (BYTEA) for certificates and encrypted keys
- **Partitioning**: Monthly partitions with automatic creation and 2-year retention
- **Security**: RLS policies, encrypted private key storage, secure serial number generation
</database_planning_summary>

<unresolved_issues>
1. **Salt Length Specification**: Exact salt length for HMAC-SHA256 hashing not determined - needs to be specified for implementation
2. **CRL Storage Format**: Whether CRL should be stored as BYTEA (binary) or TEXT (base64) - needs clarification
3. **Key Versioning Implementation**: How to implement optional key versioning for encryption algorithm upgrades - needs detailed specification
4. **Certificate Status Values**: Specific ENUM values for certificate status (active, revoked, expired, etc.) - needs definition
5. **Admin Assignment Workflow**: How admin assigns certificates to users and triggers user visibility - needs workflow specification
6. **Connection Pool Configuration**: Specific connection validation queries and retry logic implementation details
7. **PostgreSQL Function Parameters**: Exact parameters and return types for expiring certificate functions
8. **Partition Maintenance Schedule**: Specific timing for automated partition creation and cleanup procedures
9. **Backup Encryption**: Whether backup files should be encrypted and how to handle CA private key backup security
10. **Error Handling Strategy**: Database-level error handling and logging requirements for certificate operations
</unresolved_issues>
